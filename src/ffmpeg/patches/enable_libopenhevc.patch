diff --git a/FFmpeg/configure b/FFmpeg/configure
index b511835e992a3c41ca41e872dac6a32531828f07..a6fcc81fc47632cba16dbc229e11691c8efa4e66 100755
--- a/FFmpeg/configure
+++ b/FFmpeg/configure
@@ -247,6 +247,7 @@ External library support:
   --enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no]
   --enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no]
   --enable-libopencv       enable video filtering via libopencv [no]
+  --enable-libopenhevc     enable HEVC decoding via OpenHEVC [no]
   --enable-libopenh264     enable H.264 encoding via OpenH264 [no]
   --enable-libopenjpeg     enable JPEG 2000 de/encoding via OpenJPEG [no]
   --enable-libopenmpt      enable decoding tracked files via libopenmpt [no]
@@ -1735,6 +1736,7 @@ EXTERNAL_LIBRARY_LIST="
     libmp3lame
     libmysofa
     libopencv
+    libopenhevc
     libopenh264
     libopenjpeg
     libopenmpt
@@ -3119,6 +3121,7 @@ libopencore_amrwb_decoder_deps="libopencore_amrwb"
 libopenh264_decoder_deps="libopenh264"
 libopenh264_decoder_select="h264_mp4toannexb_bsf"
 libopenh264_encoder_deps="libopenh264"
+libopenhevc_decoder_deps="libopenhevc"
 libopenjpeg_decoder_deps="libopenjpeg"
 libopenjpeg_encoder_deps="libopenjpeg"
 libopenmpt_demuxer_deps="libopenmpt"
@@ -6116,6 +6119,8 @@ enabled libopencv         && { check_headers opencv2/core/core_c.h &&
                                { check_pkg_config libopencv opencv opencv2/core/core_c.h cvCreateImageHeader ||
                                  require libopencv opencv2/core/core_c.h cvCreateImageHeader -lopencv_core -lopencv_imgproc; } ||
                                require_pkg_config libopencv opencv opencv/cxcore.h cvCreateImageHeader; }
+enabled libopenhevc       && require libopenhevc libopenhevc/openhevc.h  oh_decode -lopenhevc -lm
+
 enabled libopenh264       && require_pkg_config libopenh264 openh264 wels/codec_api.h WelsGetCodecVersion
 enabled libopenjpeg       && { check_pkg_config libopenjpeg "libopenjp2 >= 2.1.0" openjpeg.h opj_version ||
                                { require_pkg_config libopenjpeg "libopenjp2 >= 2.1.0" openjpeg.h opj_version -DOPJ_STATIC && add_cppflags -DOPJ_STATIC; } }
diff --git a/FFmpeg/libavcodec/Makefile b/FFmpeg/libavcodec/Makefile
index 5e035511456b62859436908e5e7b69471511719d..b3b544f1da0ed0a5816b31a2b8c7567724b2ae13 100644
--- a/FFmpeg/libavcodec/Makefile
+++ b/FFmpeg/libavcodec/Makefile
@@ -970,6 +970,7 @@ OBJS-$(CONFIG_LIBMP3LAME_ENCODER)         += libmp3lame.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_DECODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_ENCODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRWB_DECODER)  += libopencore-amr.o
+OBJS-$(CONFIG_LIBOPENHEVC_DECODER)	  += libopenhevc.o
 OBJS-$(CONFIG_LIBOPENH264_DECODER)        += libopenh264dec.o libopenh264.o
 OBJS-$(CONFIG_LIBOPENH264_ENCODER)        += libopenh264enc.o libopenh264.o
 OBJS-$(CONFIG_LIBOPENJPEG_DECODER)        += libopenjpegdec.o
diff --git a/FFmpeg/libavcodec/allcodecs.c b/FFmpeg/libavcodec/allcodecs.c
index f2e0615f3d69bfc1fe28994ce5e32314cbb7b1b8..240327f942cc585aafc0603e320bfaabc1fdd659 100644
--- a/FFmpeg/libavcodec/allcodecs.c
+++ b/FFmpeg/libavcodec/allcodecs.c
@@ -687,6 +687,7 @@ extern AVCodec ff_libmp3lame_encoder;
 extern AVCodec ff_libopencore_amrnb_encoder;
 extern AVCodec ff_libopencore_amrnb_decoder;
 extern AVCodec ff_libopencore_amrwb_decoder;
+extern AVCodec ff_libopenhevc_decoder;
 extern AVCodec ff_libopenjpeg_encoder;
 extern AVCodec ff_libopenjpeg_decoder;
 extern AVCodec ff_libopus_encoder;
diff --git a/FFmpeg/libavcodec/libopenhevc.c b/FFmpeg/libavcodec/libopenhevc.c
new file mode 100644
index 0000000000000000000000000000000000000000..88c25891ecb847ab5601a47257c6f5c55649ec0e
--- /dev/null
+++ b/FFmpeg/libavcodec/libopenhevc.c
@@ -0,0 +1,178 @@
+/*
+ * OpenHEVC video Decoder
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libopenhevc/openhevc.h>
+#include "avcodec.h"
+#include "internal.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/opt.h"
+#include "libavutil/common.h"
+#include "libavutil/internal.h"
+
+//#define DEBUG
+typedef struct OpenHevcContext{
+	const AVClass *class;
+	OHHandle handle;
+#ifdef DEBUG
+	FILE *fout;
+#endif
+	int thread_count;
+	int thread_type;
+	int temporal_layer_id;
+	int quality_layer_id;
+}OpenHevcContext;
+static av_cold int openhevc_close(AVCodecContext *ctx)
+{
+	OpenHevcContext *c = ctx->priv_data;
+	if(c->handle){
+		oh_close(c->handle);
+		c->handle = NULL;
+	}
+#ifdef DEBUG
+	if(c->fout){
+		fclose(c->fout);
+	}
+#endif
+	return 0;
+}
+static av_cold int openhevc_init(AVCodecContext *ctx)
+{
+	OpenHevcContext *c = ctx->priv_data;
+	c->handle = oh_init(c->thread_count, c->thread_type);
+	if(!c->handle){
+		av_log(ctx,AV_LOG_ERROR,"oh_init failed\n");
+		return AVERROR_EXTERNAL;
+	}
+	size_t extra_size_alloc;
+	extra_size_alloc = ctx->extradata_size > 0 ? (ctx->extradata_size +AV_INPUT_BUFFER_PADDING_SIZE) : 0;
+	if(extra_size_alloc){
+		oh_extradata_cpy(c->handle, ctx->extradata, extra_size_alloc);
+	}
+	oh_disable_cropping(c->handle, !!(ctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP));
+	oh_start(c->handle);
+	oh_select_temporal_layer(c->handle,c->temporal_layer_id);
+	oh_select_active_layer(c->handle,c->quality_layer_id);
+	oh_select_view_layer(c->handle,c->quality_layer_id);
+#ifdef DEBUG
+	c->fout = fopen("output.yuv","wb");
+	if(!c->fout){
+		printf("open file failed !\n");
+		return -1;
+	}
+#endif
+	return 0;
+}
+
+static int openhevc_decode(AVCodecContext *ctx, void *data, int *got_frame, AVPacket *avpkt)
+{
+	OpenHevcContext *c = ctx->priv_data;
+	AVFrame *picture = data;
+	int ret;
+	OHFrame openHevcFrame;
+
+	ret = oh_decode(c->handle, avpkt->data, avpkt->size, avpkt->pts);
+	if(ret<0){
+		av_log(ctx, AV_LOG_ERROR, "failed to decode frame\n");
+		return AVERROR_EXTERNAL;
+	}
+	if(ret){
+		uint8_t *data_ptr_array[4] = {NULL};
+		int stride_array[4] = {0};
+
+		oh_output_update(c->handle, 1, &openHevcFrame);
+		oh_frameinfo_update(c->handle, &openHevcFrame.frame_par);
+
+		if(av_image_check_size(openHevcFrame.frame_par.width, openHevcFrame.frame_par.height, 0, ctx))
+			return AVERROR_INVALIDDATA;
+		ctx->pix_fmt = AV_PIX_FMT_YUV420P;
+		ff_set_dimensions(ctx, openHevcFrame.frame_par.width, openHevcFrame.frame_par.height);
+
+		if((ret=ff_get_buffer(ctx, picture, 0))<0)
+			return ret;
+		picture->sample_aspect_ratio.num = openHevcFrame.frame_par.sample_aspect_ratio.num;
+		picture->sample_aspect_ratio.den = openHevcFrame.frame_par.sample_aspect_ratio.den;
+
+		data_ptr_array[0] = (uint8_t *)openHevcFrame.data_y_p;
+		data_ptr_array[1] = (uint8_t *)openHevcFrame.data_cb_p;
+		data_ptr_array[2] = (uint8_t *)openHevcFrame.data_cr_p;
+
+		stride_array[0] = openHevcFrame.frame_par.linesize_y;
+		stride_array[1] = openHevcFrame.frame_par.linesize_cb;
+		stride_array[2] = openHevcFrame.frame_par.linesize_cr;
+#ifdef DEBUG
+		if (c->fout) {
+		    int format = openHevcFrame.frame_par.chromat_format == OH_YUV420 ? 1 : 0;
+                    fwrite( (uint8_t *)openHevcFrame.data_y_p ,  sizeof(uint8_t) , openHevcFrame.frame_par.linesize_y  * openHevcFrame.frame_par.height,  c->fout);
+                    fwrite( (uint8_t *)openHevcFrame.data_cb_p , sizeof(uint8_t) , openHevcFrame.frame_par.linesize_cb * openHevcFrame.frame_par.height >> format, c->fout);
+                    fwrite( (uint8_t *)openHevcFrame.data_cr_p , sizeof(uint8_t) , openHevcFrame.frame_par.linesize_cr * openHevcFrame.frame_par.height >> format, c->fout);
+                                }
+#endif
+//		av_image_copy(picture->data, picture->linesize, (uint8_t **)data_ptr_array, stride_array, ctx->pix_fmt, picture->width, picture->height);
+		picture->data[0] = data_ptr_array[0];
+		picture->data[1] = data_ptr_array[1];
+		picture->data[2] = data_ptr_array[2];
+		picture->linesize[0] = stride_array[0];
+		picture->linesize[1] = stride_array[1];
+		picture->linesize[2] = stride_array[2];
+		picture->format = ctx->pix_fmt;
+
+		picture->pts = avpkt->pts;
+	        picture->pkt_dts = avpkt->dts;
+		picture->pkt_duration = avpkt->duration;
+
+		*got_frame = 1;
+	}
+	return avpkt->size;
+
+}
+static void openhevc_flush(AVCodecContext *avctx)
+{
+	OpenHevcContext *c = avctx->priv_data;
+	oh_flush(c->handle);
+}
+#define OFFSET(x) offsetof(OpenHevcContext, x)
+#define VE (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption options[] = {
+	{"thread_count", "for how many threads to be executed, 1 is for default", OFFSET(thread_count), AV_OPT_TYPE_INT, {.i64 = 1}, 0, INT_MAX, VE},
+	{"thread_type", "which multithreads methods to use, 1 is for default", OFFSET(thread_type), AV_OPT_TYPE_INT, {.i64 = 1}, 0, INT_MAX, VE},
+	{"temporal_layer_id","temporal layer id,7 is for default",OFFSET(temporal_layer_id),AV_OPT_TYPE_INT,{.i64 = 7}, 0 , INT_MAX, VE},
+	{"quality_layer_id","quality layer id,0 is for default",OFFSET(quality_layer_id),AV_OPT_TYPE_INT,{.i64 = 0}, 0 , INT_MAX, VE},
+	{NULL},
+};
+static const AVClass openhevc_class = {
+	.class_name = "libopenhevc",
+	.item_name = av_default_item_name,
+	.option = options,
+	.version = LIBAVUTIL_VERSION_INT,
+};
+AVCodec ff_libopenhevc_decoder = {
+	.name = "libopenhevc",
+	.long_name = NULL_IF_CONFIG_SMALL("libopenhevc HEVC decoder"),
+	.type = AVMEDIA_TYPE_VIDEO,
+	.id = AV_CODEC_ID_HEVC,
+	.priv_data_size = sizeof(OpenHevcContext),
+	.priv_class = &openhevc_class,
+	.init = openhevc_init,
+	.flush = openhevc_flush,
+	.close = openhevc_close,
+	.decode = openhevc_decode,
+	.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1,
+	.caps_internal = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+};
